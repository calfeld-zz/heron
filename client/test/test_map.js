// Generated by CoffeeScript 1.6.3
(function() {
  var M, assert;

  assert = require("chai").assert;

  M = require("map.js").Heron.Map;

  describe('Heron.Map', function() {
    describe('ObjectMap', function() {
      var map, obj;
      describe('constructor', function() {
        it('should support no arguments', function() {
          return assert.deepEqual({}, new M.ObjectMap().get());
        });
        return it('should support an object', function() {
          var obj;
          obj = {
            foo: 'bar'
          };
          return assert.deepEqual(obj, new M.ObjectMap(obj).get());
        });
      });
      obj = {
        foo: 'bar',
        baz: 'buz',
        hello: 'world'
      };
      map = new M.ObjectMap(obj);
      describe('get', function() {
        return it('should return the keys asked for', function() {
          var result;
          result = map.get('foo', 'baz');
          assert.equal(obj.foo, result.foo);
          return assert.equal(obj.baz, result.baz);
        });
      });
      describe('gets', function() {
        return it('should return the value of the key asked for', function() {
          return assert.equal(obj.foo, map.gets('foo'));
        });
      });
      describe('geta', function() {
        return it('should return an array of values of the keys asked for', function() {
          return assert.deepEqual([obj.foo, obj.baz], map.geta('foo', 'baz'));
        });
      });
      describe('keys', function() {
        return it('should return the keys of the map', function() {
          var k;
          k = map.keys();
          assert.equal(3, k.length);
          assert.notEqual(-1, k.indexOf('baz'));
          assert.notEqual(-1, k.indexOf('foo'));
          return assert.notEqual(-1, k.indexOf('hello'));
        });
      });
      return describe('set', function() {
        var m, o;
        o = {
          foo: 'baz'
        };
        m = new M.ObjectMap(o);
        it('should change the value', function() {
          m.set({
            foo: 'buz'
          });
          return assert.equal('buz', m.gets('foo'));
        });
        return it('should allow adding a value', function() {
          m.set({
            hello: 'world'
          });
          return assert.equal('world', m.gets('hello'));
        });
      });
    });
    describe('map', function() {
      it('should turn an object into a map', function() {
        var obj;
        obj = {
          foo: 'bar'
        };
        return assert.equal('bar', M.map(obj).gets('foo'));
      });
      return it('should leave a map alone', function() {
        var map;
        map = new M.ObjectMap({
          foo: 'bar'
        });
        return assert.equal(map, M.map(map));
      });
    });
    return describe('ParametricMap', function() {
      it('should return normal values normally', function() {
        return assert.equal('bar', new M.ParametricMap({
          foo: 'bar'
        }).gets('foo'));
      });
      it('should evlauate function values', function() {
        return assert.equal('bar', new M.ParametricMap({
          foo: function() {
            return 'bar';
          }
        }).gets('foo'));
      });
      return it('should recursively evaluate functions.', function() {
        return assert.equal('bar', new M.ParametricMap({
          foo: function() {
            return function() {
              return 'bar';
            };
          }
        }).gets('foo'));
      });
    });
  });

}).call(this);
